# üê¢ Turtlesim ‚ÄúCatch Them All‚Äù ‚Äî ROS 2 Project

This project implements an autonomous multi-node ROS 2 system using the **turtlesim** simulator.  
The goal is to control a master turtle (`turtle1`) that continuously seeks out, catches, and removes other turtles spawned in the environment.

![Demo video](media/Turtlesim_Demo.gif)

Rather than focusing only on code, this project emphasizes **system design**, **clear separation of responsibilities**, and **correct use of ROS 2 communication patterns** (topics, services, and parameters).

---

## Table of Contents

- [üìê System Architecture](#-system-architecture)
- [üß© Nodes Overview](#-nodes-overview)
  - [1. `turtlesim_node` (simulation backend)](#1-turtlesim_node-simulation-backend)
  - [2. `turtle_controller` (autonomous controller)](#2-turtle_controller-autonomous-controller)
  - [3. `turtle_spawner` (population manager)](#3-turtle_spawner-population-manager)
- [üì° Topics](#-topics)
  - [`/turtle1/pose`](#turtle1pose)
  - [`/turtle1/cmd_vel`](#turtle1cmd_vel)
  - [`/alive_turtles`](#alive_turtles)
- [üîÅ Services](#-services)
  - [`/spawn`](#spawn)
  - [`/kill`](#kill)
  - [`/catch_turtle` (custom service)](#catch_turtle-custom-service)
- [üß† Design Notes](#-design-notes)
- [üöÄ How to Run](#-how-to-run)
  - [Prerequisites](#prerequisites)
  - [Build](#build)
  - [Run](#run)
- [üöÄ Design Rationale](#-design-rationale)
  - [Control Loop](#control-loop)
  - [Target Selection](#target-selection)
  - [Catch Flow](#catch-flow)
- [üöÄ Future Extensions](#-future-extensions)
- [üìö References](#-references)

## üìê System Architecture

The system is composed of three ROS 2 nodes that communicate using topics and services.

A high-level architecture diagram is provided below:

[`üëâ System Architecture (draw.io)`](media/Catch_Them_All_Turtlesim_Project.jpg)

> The diagram illustrates node responsibilities, data flow through topics, and request‚Äìresponse interactions via services.

---

## üß© Nodes Overview

### 1. `turtlesim_node` (simulation backend)

**Role:** Simulation engine and turtle lifecycle manager

- Provided by the `turtlesim` package
- Maintains turtle states (position, orientation, motion)
- Executes velocity commands for turtles
- Publishes pose data for controlled turtles
- Acts as a **service server** for:
  - `/spawn` ‚Äî create new turtles
  - `/kill` ‚Äî remove turtles from the simulation

This node represents the **environment** in which the system operates.

---

### 2. `turtle_controller` (autonomous controller)

**Role:** Motion control and target-seeking logic

- Controls the master turtle (`turtle1`)
- Subscribes to `/turtle1/pose` for real-time feedback
- Publishes velocity commands to `/turtle1/cmd_vel`
- Runs a periodic control loop using a proportional (P) controller ([see design notes](media/theroy_behind_the_proportional_controller.png))
- Subscribes to `/alive_turtles` to identify available targets
- Selects a turtle to pursue (first or closest, depending on logic)
- Acts as a **service client** for `/catch_turtle` when a target is reached

This node contains the system‚Äôs **decision-making and control logic**.

---

### 3. `turtle_spawner` (population manager)

**Role:** Turtle creation, tracking, and removal coordination

- Periodically spawns turtles at random positions
- Calls `/spawn` to create new turtles
- Maintains an internal list of all currently alive turtles
- Publishes turtle names and coordinates on `/alive_turtles`
- Calls `/kill` to remove turtles when they are caught
- Acts as a **service server** for `/catch_turtle`

This node owns the **global state** of which turtles exist.

---

## üì° Topics

### `/turtle1/pose`

- Publishes real-time pose (position and orientation) of `turtle1`
- Used by `turtle_controller` for closed-loop control

### `/turtle1/cmd_vel`

- Carries velocity commands generated by the controller
- Consumed by `turtlesim_node` to update motion

### `/alive_turtles`

- Publishes a list of currently alive turtles and their coordinates
- Enables target selection by the controller

---

## üîÅ Services

### `/spawn`

- **Server:** `turtlesim_node`
- **Client:** `turtle_spawner`
- Creates a new turtle at a specified location

### `/kill`

- **Server:** `turtlesim_node`
- **Client:** `turtle_spawner`
- Removes a turtle from the simulation

### `/catch_turtle` (custom service)

- **Server:** `turtle_spawner`
- **Client:** `turtle_controller`
- Signals that a turtle has been caught and should be removed

---

## üß† Design Notes

- Topics are used for **continuous state sharing**
- Services are used for **discrete actions**
- Each node has a **single clear responsibility**
- The architecture scales naturally with parameters and launch files
- The system design closely follows ROS 2 best practices

---

## üöÄ How to Run

### Prerequisites

- ROS 2 installed and sourced
- `turtlesim` package available

### Build

From the workspace root:

```bash
cd ros2_ws
colcon build
source install/setup.bash
```

### Run

In separate terminals (after sourcing `install/setup.bash` in each):

```bash
ros2 run turtlesim turtlesim_node
```

```bash
ros2 run turtlesim_main_py_pkg turtle_spawner
```

```bash
ros2 run turtlesim_main_py_pkg turtle_controller
```

Alternatively, use the bringup launch file:

```bash
ros2 launch turtlesim_bringup turtlesim_app.launch.xml
```

or the helper script (just run this command), but make sure it is executable and has the correct workspace path:

```bash
ros2_ws/src/launch_helper/helper.sh
```

---

## üöÄ Design Rationale

### Control Loop

The controller uses a proportional (P) controller so velocity scales with position error. This keeps the system responsive without overshooting heavily in a simple 2D simulator.

### Target Selection

Targets are selected from the `/alive_turtles` list. The selection strategy is to take the closest. This can be easily modified to implement different strategies (e.g. random selection, first in list).

### Catch Flow

The controller signals a catch via a service call rather than publishing a topic event. This enforces a single, acknowledged removal action by the spawner and prevents duplicate kills.

## üöÄ Future Extensions

- Implement different control strategies (e.g. full PID controller)
- Support multiple controllers
- Visualize performance metrics

---

## üìö References

- ROS 2 Documentation  
- Turtlesim package  
- Project guide: *ROS 2 for Beginners ‚Äì Turtlesim ‚ÄúCatch Them All‚Äù*
- [Proportional Control Theory](https://en.wikipedia.org/wiki/Proportional_control)
